---
title: "EpiVerse Organizational Overview"
execute:
  echo: false
format:
  html:
    theme: yeti
---

```{r libraries, message = FALSE}
library (bslib)
library (bsicons)
library (htmltools)
library (plotly)
```

```{r valuebox-values}
repo_data <- readRDS (fs::path ("data", "results-data-repo-src.Rds"))
annual_commits <- readRDS (fs::path ("data", "results-annual-commits.Rds"))
annual_gh_activity <- readRDS (fs::path ("data", "results-annual-gh-activity.Rds"))
annual_gh_activity$total <- rowSums (annual_gh_activity [, -1])
num_repos <- nrow (repo_data)
repo_orgs <- gsub ("\\/.*$", "", repo_data$orgrepo) |>
    table () |>
    sort (decreasing = TRUE) |>
    head (n = 3L)
```


```{r}
# This code identifies packages with high community engagement yet low
# developer responsiveness. It identifies packages lying in the lower-right
# corner of the quadrant frormed by the regerssion and its perpendicular
# through the mid-point of the entire plane, and lying below the 90% CI.
ci_level <- 0.9
m <- readRDS (fs::path ("data", "results-maintenance-org.Rds")) |>
    dplyr::rename (x = comm_engage, y = dev_resp) |>
    dplyr::filter (date == max (date)) |>
    dplyr::select (-date)
x_mid <- min (m$x) + diff (range (m$x)) / 2
y_mid <- min (m$y) + diff (range (m$y)) / 2

mod <- lm (y ~ x, data = m)
slope <- coefficients (mod) [2]
intercept <- coefficients (mod) [1]
perp_slope <- -1 / slope
perp_intercept <- y_mid - perp_slope * x_mid

ci <- predict (mod, interval = "confidence", level = ci_level) |>
    as.data.frame ()
data <- cbind (m, ci) |>
    dplyr::mutate (
        below_ci = y < lwr,
        pos_reg = y - (slope * x + intercept),
        pos_perp = y - (perp_slope * x + perp_intercept),
        index_lr_quad = pos_reg < 0 & pos_perp > 0,
        target_points = index_lr_quad & below_ci
    ) |>
    dplyr::filter (target_points) |>
    dplyr::select (package, x, y) |>
    dplyr::rename (comm_engage = x, dev_resp = y)
repo_urls <- repo_data |>
    dplyr::select (package, url)
data <- dplyr::left_join (data, repo_urls, by = "package")

npkgs_requiring_maintenance <- nrow (data)

# library (ggplot2)
# ggplot (m, aes (x = x, y = y)) +
#     geom_point (cex = 2, col = "yellow") +
#     geom_smooth (method = "lm", formula = "y ~ x", se = TRUE) +
#     geom_abline (slope = perp_slope, intercept = perp_intercept, col = "blue", lty = 2) +
#     geom_point (data = data, col = "red", cex = 2) +
#     ggplot2::theme_minimal ()
```

This dashboard presents metrics and models for each repository within the
[`epiverse-trace`](https://github.com/epiverse-trace),
[`reconhub`](https://github.com/reconhub), and
[`reconverse`](https://github.com/reconverse) GitHub organizations, and some
related repositories from other sources. These organizations are linked under the
`r bsicons::bs_icon("github")` icon on the top right. The dashboard is intended
to demonstrate the kinds of analyses and insights that are possible, and is
expected to change and develop a lot. Please provide feedback by clicking on
the `r bsicons::bs_icon("github")` symbol and selecting "_Feedback_".


```{r}
# Style <a> hyperlinks in first card for repo overviews:
org_links <- paste0 (
    unname (repo_orgs), " from ",
    "<a style='color:white; text-decoration:underline;' href='https://github.com/",
    names (repo_orgs),
    "'>",
    names (repo_orgs),
    "</a>"
)
org_icons <- lapply (seq_along (repo_orgs), function (i) {
    bsicons::bs_icon (paste0 (i, "-square"))
})

# Style <a> hyperlinks for second card of urgent maintenance:
style <- "color:white; text-decoration:underline;"
onclick <- "localStorage.setItem('orgmetricsRepo', "
pkg_links <- sprintf (
    '<a href=\'/repo.html\' style="%s" onclick="%s \'%s\')">%s</a>',
    style,
    onclick,
    data$package,
    data$package
)
n_urgent <- paste0 (
    npkgs_requiring_maintenance,
    " repositor",
    ifelse (npkgs_requiring_maintenance == 1, "y", "ies")
)

bslib::page_fillable (
    bslib::layout_columns (
        bslib::value_box (
            full_screen = FALSE,
            fill = TRUE,
            title = "There are",
            value = paste0 (format (num_repos, big.mark = ","), " repositories"),
            showcase = bsicons::bs_icon ("clipboard-data"),
            showcase_layout = "top right",
            theme = "bg-gradient-blue-orange",
            htmltools::p ("including"),
            lapply (seq_along (org_links), function (i) {
                htmltools::p (org_icons [i], htmltools::HTML (org_links [i]))
            })
        ),
        bslib::value_box (
            full_screen = FALSE,
            fill = FALSE,
            title = "Urgent mainetance required",
            value = n_urgent,
            showcase = bsicons::bs_icon ("tools"),
            showcase_layout = "top right",
            htmltools::div (
                htmltools::p (paste0 (
                    "with high community engagement, ",
                    "yet low developer responsiveness:"
                )),
                htmltools::br (),
                htmltools::tagList (
                    lapply (seq_len (nrow (data)), function (i) {
                        tags$p (
                            bsicons::bs_icon ("caret-right"),
                            htmltools::HTML (pkg_links [i])
                        )
                    })
                )
            ),
            theme = "bg-gradient-yellow-orange"
        ),
        col_widths = c (6, 6)
    )
)
```



```{r sparkline-plot-commits, echo = FALSE}
sparkline_plot_commits_in <- function (annual_commits) {
    x <- as.integer (annual_commits$year)
    y <- annual_commits$num_commits
    x_lim <- range (x)
    y_lim <- c (0, max (y) * 1.05)

    par (mar = c (3, 0, 0, 0), bg = "#20c997")
    plot (
        x,
        y,
        type = "n",
        axes = FALSE,
        frame.plot = FALSE,
        ylim = y_lim,
        xlim = x_lim,
        ylab = "",
        xlab = "",
        yaxs = "i",
        xaxs = "i",
    )

    lines (x, y, type = "l", pch = NA, col = "#0B538E", lwd = 3)

    polygon_x <- c (x [1], x, x [length (x)])
    polygon_y <- c (0, y, 0)

    polygon (polygon_x, polygon_y, col = "#e6f2fd", border = NA)
}
sparkline_plot_commits <- function () {
    as_fill_item (
        htmltools::plotTag (
            sparkline_plot_commits_in (annual_commits),
            suppressSize = "xy",
            alt = "sparkline plot of annual numbers of commits."
        )
    )
}
```

```{r sparkline-plot-gh, echo = FALSE}
sparkline_plot_gh_in <- function (annual_gh) {
    x <- as.integer (annual_gh$year)
    y <- annual_gh$total
    x_lim <- range (x)
    y_lim <- c (0, max (y) * 1.05)

    par (mar = c (3, 0, 0, 0), bg = "#20c997")
    plot (
        x,
        y,
        type = "n",
        axes = FALSE,
        frame.plot = FALSE,
        ylim = y_lim,
        xlim = x_lim,
        ylab = "",
        xlab = "",
        yaxs = "i",
        xaxs = "i",
    )

    lines (x, y, type = "l", pch = NA, col = "#0B538E", lwd = 3)

    polygon_x <- c (x [1], x, x [length (x)])
    polygon_y <- c (0, y, 0)

    polygon (polygon_x, polygon_y, col = "#e6f2fd", border = NA)
}
sparkline_plot_gh <- function () {
    as_fill_item (
        htmltools::plotTag (
            sparkline_plot_gh_in (annual_gh_activity),
            suppressSize = "xy",
            alt = "sparkline plot of annual GitHub activity."
        )
    )
}
```

```{r echo = FALSE, message = TRUE}
lines <- paste0 (unname (repo_orgs), " from ", names (repo_orgs))
bslib::page_fillable (
    bslib::layout_columns (
        bslib::value_box (
            title = "Total commits:",
            value = format (sum (annual_commits$num_commits), big.mark = ","),
            htmltools::p (
                "between ",
                min (as.integer (annual_commits$year)),
                " and ",
                max (as.integer (annual_commits$year))
            ),
            htmltools::p ("(Plot below shows time series)"),
            showcase = sparkline_plot_commits (),
            showcase_layout = "bottom",
            theme = "bg-teal"
        ),
        value_box (
            title = "GitHub Activity",
            value = format (sum (annual_gh_activity$total), big.mark = ","),
            htmltools::p (
                "Total issues, comments, and pull requests"
            ),
            showcase = sparkline_plot_gh (),
            showcase_layout = "bottom",
            theme = "bg-teal"
        ),
        col_widths = c (6, 6),
    )
)
```


<!--- ----------------------------------------------------- --->

-----

The dashboard currently has four main pages:

1. This main page which provides an organizational overview, and identifies
   maintenance priorities across all repositories.
2. A [repository maintenance](./repo.html) page providing additional
   detail on maintenance needs of any selected repository.
3. A [contributor](/contributor.html) page with details of individual
   maintainers and contributors, their repositories and co-contributors.
4. A [*Community Health*](./models.html) providing additional detail on scores
   for the various [CHAOSS (*Community Health Analytics in Open Source
    Software*) models and
    metrics](https://chaoss.community/kb-metrics-and-metrics-models/) for each
    repository.

This dashboard currently only considers repositories which are R packages, and
thus every repository is also a package. Some aspects measured here, like the
following dependency network, rely on structures specific to R packages, while
other aspects are more related to the structure of repositories on GitHub. The
terms "repository" and "package" may nevertheless be considered
interchangeable.

## Package Network

This graph shows dependencies between all packages which use any other
organization package. Nodes show individual packages, with circles for each
package scaled by total numbers of dependent packages; that is, numbers of
other packages which depend on that package. Edges connect dependent packages,
with thicknesses scaled by total numbers of function calls by all dependent
packages.

```{r}
data_pkgcheck <- readRDS (fs::path ("data", "results-pkgcheck.Rds"))
pkg_deps <- lapply (data_pkgcheck, function (i) {
    cbind (name = i$pkg$name, i$pkg$dependencies)
})
pkg_deps <- do.call (rbind, unname (pkg_deps)) |>
    dplyr::filter (package %in% unique (name))

nodes <- data.frame (
    id = unique (c (pkg_deps$package, pkg_deps$name)),
    size = 0L
)
pkg_counts <- table (pkg_deps$package)
index <- match (names (pkg_counts), nodes$id)
nodes$size [index] <- as.integer (pkg_counts)
nodes$size <- nodes$size + 1

pkg_deps$ncalls [is.na (pkg_deps$ncalls)] <- 0L
pkg_deps$ncalls <- pkg_deps$ncalls + 1L
edges <- data.frame (
    source = pkg_deps$name,
    target = pkg_deps$package,
    value = pkg_deps$ncall
)

ojs_define (nodes_in = nodes)
ojs_define (edges_in = edges)
```

```{ojs}
pkg_nodes = {
    return transpose(nodes_in).map(row => ({
        ...row,
    }));
}
pkg_edges = {
    return transpose(edges_in).map(row => ({
        ...row,
    }));
}
```

<!--------- break -------->


```{ojs ForceGraph-plot}
strength = -400;

chart = {

    const width = 928;
    const height = 600;

    const types = Array.from(new Set(pkg_nodes.map(d => d.group)));

    const color = d3.scaleOrdinal(types, d3.schemeCategory10);

    const simulation = d3.forceSimulation(pkg_nodes)
        .force("link", d3.forceLink(pkg_edges).id(d => d.id))
        .force("charge", d3.forceManyBody().strength(strength))
        .force("x", d3.forceX())
        .force("y", d3.forceY());

    const svg = d3.create("svg")
        .attr("viewBox", [-width / 2, -height / 2, width, height])
        .attr("width", width)
        .attr("height", height)
        .attr("style", "max-width: 100%; height: auto; font: 14px sans-serif;");

    const link = svg.append("g")
        .attr("fill", "none")
        .attr("stroke-width", 1.5)
        .selectAll("path")
        .data(pkg_edges)
        .join("path")
            .attr("stroke", "gray")
            .attr("stroke-width", d => d.value);

    const node = svg.append("g")
        .selectAll("g")
        .data(pkg_nodes)
        .join("g")
            .call(drag(simulation));

    node.append("circle")
        .attr("stroke", "white")
        .attr("stroke-width", 1.5)
        .data(pkg_nodes)
        .join("circle")
            .attr("fill", d => color(d.group))
            .attr("r", d => d.size);

    node.append("text")
        .attr("x", 8)
        .attr("y", "0.31em")
        .text(d => d.id)
        .html(d =>
            `<a href="/repometrics-demo/repo.html"
                onclick="localStorage.setItem('orgmetricsRepo', '${d.id}')">${d.id}</a>`)
        .clone(true).lower()
            .attr("fill", "none")
            .attr("stroke", "white")
            .attr("stroke-width", 3);

    simulation.on("tick", () => {
        link.attr("d", linkArc);
        node.attr("transform", d => `translate(${d.x},${d.y})`);
    });

    invalidation.then(() => simulation.stop());

    return Object.assign(svg.node(), {scales: {color}});
}
```

```{ojs}
function linkArc(d) {
    const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);
    return `
    M${d.source.x},${d.source.y}
    A${r},${r} 0 0,1 ${d.target.x},${d.target.y}
    `;
}
```

```{ojs}
drag = simulation => {

    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    return d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended);
}
```


---

<!---
******** START UTILITY FUNCTIONS ********
--->


```{ojs}
function sparkbar(max) {
  const colourScale = d3.scaleSequential(d3.interpolateCool)
    .domain([0, max]);

  return (x) => htl.html`<div style="
    background: ${colourScale(x)};
    color: black;
    width: ${100 * x / max}%;
    float: right;
    padding-right: 3px;
    box-sizing: border-box;
    overflow: visible;
    display: flex;
    justify-content: end;">${x.toFixed(2).toLocaleString("en-US")}`
}

function tooltip(title, expl) {
    const th = document.createElement("th");

    th.title = expl

    th.style.display = "flex";
    th.style.justifyContent = "flex-end";
    th.style.backgroundColor = "#f0f8ff";
    th.style.width = "100%";
    th.style.position = "relative";

    const textSpan = document.createElement("span");

    textSpan.textContent = title;
    textSpan.style.flex = "1";
    textSpan.style.textAlign = "right";
    textSpan.style.position = "static";
    textSpan.style.wordWrap = "break-word";
    textSpan.style.overflowWrap = "break-word";
    textSpan.style.whiteSpace = "normal";

    th.appendChild(textSpan);

    th.addEventListener("mouseover", () => th.style.background = "#d0e8ff");
    th.addEventListener("mouseout", () => th.style.background = "#f0f8ff");

    return th;
}

function pkgfmt(pkg) {
    const th = document.createElement("th");
    th.title = "hover"
    th.style.background = "#f0f8ff";
    th.textContent = pkg;

    th.addEventListener("mouseover", () => th.style.background = "#d0e8ff");
    th.addEventListener("mouseout", () => th.style.background = "#f0f8ff");

    th.addEventListener("click", () => {
        localStorage.setItem("orgmetricsRepo", pkg);
        th.style.background="#a0f8ff";
        window.location.href="/repometrics-demo/repo.html";
    });

    return th;
}

function ctbfmt(ctb) {
    const th = document.createElement("th");
    th.title = "hover"
    th.style.background = "#f0f8ff";
    th.textContent = ctb;

    th.addEventListener("mouseover", () => th.style.background = "#d0e8ff");
    th.addEventListener("mouseout", () => th.style.background = "#f0f8ff");


    th.addEventListener("click", () => {
        localStorage.setItem('orgmetricsMaintainer', ctb);
        th.style.background="#a0f8ff";
        window.location.href="/repometrics-demo/contributor.html";
    });

    return th;
}
```

<!---
******** END UTILITY FUNCTIONS ********
--->


## Aggregate metrics

This second presents aggregated results from statistics assessed for each
repository, and aggregated across the organizations into four distinct
categories:

1. _Development_: Metrics of both code development and maintainer continuity
   and diversity. High scores reflect repositories with high levels of code
   development from a diverse community of maintainers.
2. _GitHub_: Metrics derived from GitHub issues and pull requests. High scores
   reflect repositories with active use of issues, pull requests, code reviews,
   and rapid responses from core maintainers to issues or pull requests opened
   by wider community members.
3. _Popularity_: Metrics of repository popularity, derived from CRAN download
   numbers (where applicable), GitHub stars and forks, and issue comments from
   user communities beyond core maintainers.
4. _Dependencies and Releases_: High scores reflect repositories with fewer
   dependencies and frequent releases.

The _Overall_ column is an average of all metrics across all of these four
categorical groupings, and provides an overall metric of repository health.


<!---
******** START PLOT OF AVERAGE METRICS OVER DATES ********
--->

```{r}
data_metrics <- readRDS (fs::path ("data", "results-metrics.Rds"))
# These currently have too many datees, and will be fixed with next update
# (already fixed via #27). These lines can then be deleted.
# ----- START DATE FIX -----
dates <- as.Date (names (data_metrics))
latest <- as.Date (max (names (data_metrics)))
date_seq <- repometrics:::get_end_date_seq (end_date = latest, num_years = 3)
index <- vapply (
    date_seq,
    function (i) which.min (abs (difftime (dates, i))),
    integer (1L)
)
# cli::cli_inform ("reducing metrics from {length(dates)} to {length(index)}")
data_metrics <- data_metrics [index]
# ----- END DATE FIX -----

# Grouped metrics over dates
metrics_dates <- lapply (data_metrics, function (m) {
    m |>
        tidyr::pivot_wider (names_from = name, values_from = value) |>
        orgmetrics:::data_metrics_group () |>
        dplyr::select (-dplyr::any_of ("none")) |>
        dplyr::relocate (total, .after = package) |>
        dplyr::arrange (by = desc (total)) |>
        dplyr::summarise (dplyr::across (dplyr::where (is.numeric), mean))
})
metrics_dates <- do.call (rbind, metrics_dates)
# dplyr::add_rownames is now tibble::rownames_to_column(), but no tibble here
metrics_dates <- cbind (date = rownames (metrics_dates), metrics_dates)
rownames (metrics_dates) <- NULL
metrics_dates <- metrics_dates |>
    tidyr::pivot_longer (-date) |>
    dplyr::mutate (date = as.Date (date))
metrics_dates$name [metrics_dates$name == "total"] <- "Overall"
metrics_dates$name [metrics_dates$name == "development"] <- "Development"
metrics_dates$name [metrics_dates$name == "issues"] <- "GitHub"
metrics_dates$name [metrics_dates$name == "popularity"] <- "Popularity"
metrics_dates$name [metrics_dates$name == "meta"] <- "Dep.+Rel."

ojs_define (metrics_dates_in = metrics_dates)
```


```{ojs}
metricsData = {
    return transpose(metrics_dates_in).map(row => ({
        ...row,
        date: new Date(row.date)
    }));
}
```

```{ojs}
Plot.plot({
    color: {
        legend: true,
        label: "name",
        swatchHeight: 4,
        domain: ["Development", "GitHub", "Popularity", "Dep.+Rel.", "Overall"],
    },
    marks: [
        Plot.lineY(metricsData, {
            x: "date",
            y: "value",
            stroke: "name",
            strokeWidth:  2,
            strokeDasharray: "2,5",
        }),
        Plot.linearRegressionY(metricsData, {
            x: "date",
            y: "value",
            stroke: "name",
            strokeWidth: 2,
            ci: 0
        }),
        Plot.axisY({
            label: null,
        }),
    ],
    x: {
        grid: true,
        type: "utc",
        domain: [d3.min(metricsData, d => d.date), d3.max(metricsData, d => d.date)],
        tickFormat: "%Y", 
        ticks: [...new Set(metricsData.map(d => d.date.getFullYear()))].map(year => new Date(`${year}-01-01`)),
    },
    y: { grid: true },
    style: {
        fontSize: '16px',
    }
})
```

<!---
******** END PLOT OF AVERAGE METRICS OVER DATES ********
--->

<!---
******** START REPO-LEVEL METRICS TABLE ********
--->

The following table shows metrics for each package, for the latest time period
only aggregated into each of the four groups. Clicking on the "package" values
will lead to the repository maintenance page with further details of the
selected package or repository.

```{r}
data_metrics <- readRDS (fs::path ("data", "results-metrics.Rds"))

# Main table of most recent metrics:
# which.max does not work for dates, but max does
index1 <- which (names (data_metrics) == max (names (data_metrics)))
m <- data_metrics [[index1]] |>
    tidyr::pivot_wider (names_from = name, values_from = value) |>
    orgmetrics:::data_metrics_group () |>
    dplyr::select (-none) |>
    dplyr::relocate (total, .after = package) |>
    dplyr::arrange (by = desc (total))
ojs_define (metrics_table_in = m)
```

```{ojs}
metricsGroupedTable = {
    return transpose(metrics_table_in).map(row => ({
        ...row,
    }));
}
```

```{ojs}
Inputs.table(metricsGroupedTable, {
    width: {
        package: 100,
        total: 200,
        development: 200,
        issues: 200,
        popularity: 200,
        meta: 200,
    },
    format: {
        package: d => pkgfmt(d),
        development: sparkbar(d3.max(metricsGroupedTable, d => d.development)),
        issues: sparkbar(d3.max(metricsGroupedTable, d => d.issues)),
        popularity: sparkbar(d3.max(metricsGroupedTable, d => d.popularity)),
        meta: sparkbar(d3.max(metricsGroupedTable, d => d.meta)),
        total: sparkbar(d3.max(metricsGroupedTable, d => d.total)),
    },
    header: {
        development: tooltip("Development", "Code development and maintenance metrics"),
        issues: tooltip("Issues", "GitHub issues and pull request activity"),
        popularity: tooltip("Popularity", "Project popularity on CRAN (where applicable) and GitHub"),
        meta: tooltip("Dependencies and releases", ""),
        total: tooltip("Overall", "Average across all four categories of metrics."),
    },
})
```

<!---
******** END REPO-LEVEL METRICS TABLE ********
--->

<!---
******** START PLOT OF MAINTENANCE DEFICIT OVER DATES ********
--->

## Maintenance deficit

This next graph shows the maintenance deficit over time, as the difference
between community engagement and developer responsiveness. Repositories with
high community engagement yet low developer responsiveness have a high
maintenance deficit, and vice-versa. The "Deficit" scores are scaled to fix
within the same range as the metrics of community engagement and developer
responsiveness.

```{r}
maintenance_ts <- readRDS (fs::path ("data", "results-maintenance-org.Rds")) |>
    dplyr::group_by (date) |>
    dplyr::summarise (
        comm_engage = mean (comm_engage),
        dev_resp = mean (dev_resp),
        maintenance = mean (maintenance)
    )
maintenance_ts$maintenance <- maintenance_ts$maintenance -
    mean (maintenance_ts$maintenance) +
    mean ((maintenance_ts$comm_engage + maintenance_ts$dev_resp) / 2)
maintenance_ts <- maintenance_ts |> tidyr::pivot_longer (-date)
maintenance_ts$name [maintenance_ts$name == "comm_engage"] <- "Comm. Engage."
maintenance_ts$name [maintenance_ts$name == "dev_resp"] <- "Dev. Resp."
maintenance_ts$name [maintenance_ts$name == "maintenance"] <- "Deficit"

ojs_define (maintenance_ts_in = maintenance_ts)
```

```{ojs}
maintenanceData = {
    return transpose(maintenance_ts_in).map(row => ({
        ...row,
        date: new Date(row.date)
    }));
}
```

```{ojs}
Plot.plot({
    color: {
        legend: true,
        label: "name",
        swatchHeight: 4,
        domain: ["Comm. Engage.", "Dev. Resp.", "Deficit"],
    },
    marks: [
        Plot.lineY(maintenanceData, {
            x: "date",
            y: "value",
            stroke: "name",
            strokeWidth:  2,
            strokeDasharray: "2,5",
        }),
        Plot.linearRegressionY(maintenanceData, {
            x: "date",
            y: "value",
            stroke: "name",
            strokeWidth: 2,
            ci: 0
        }),
        Plot.axisY({
            label: null,
        }),
    ],
    x: {
        grid: true,
        type: "utc",
        domain: [d3.min(metricsData, d => d.date), d3.max(metricsData, d => d.date)],
        tickFormat: "%Y",
        ticks: [...new Set(metricsData.map(d => d.date.getFullYear()))].map(year => new Date(`${year}-01-01`)),
    },
    y: { grid: true },
    style: {
        fontSize: '16px',
    }
})
```

And these are maintenance deficit values for individual repositories
(packages), for the latest time period only.

```{r}
maintenance_repo <- readRDS (fs::path ("data", "results-maintenance-org.Rds")) |>
    dplyr::filter (date == max (date)) |>
    dplyr::select (-date) |>
    dplyr::mutate (
        maintenance = maintenance -
            mean (maintenance) + mean (c (comm_engage + dev_resp) / 2)
    ) |>
    dplyr::arrange (dplyr::desc (maintenance))
ojs_define (maintenance_repo_in = maintenance_repo)
```


```{ojs}
maintenanceRepoData = {
    return transpose(maintenance_repo_in).map(row => ({
        ...row,
    }));
}
```

```{ojs}
Inputs.table(maintenanceRepoData, {
    width: {
        package: 100,
        comm_engage: 200,
        dev_resp: 200,
        maintenance: 200,
    },
    format: {
        package: d => pkgfmt(d),
        comm_engage: sparkbar(d3.max(maintenanceRepoData, d => d.comm_engage)),
        dev_resp: sparkbar(d3.max(maintenanceRepoData, d => d.dev_resp)),
        maintenance: sparkbar(d3.max(maintenanceRepoData, d => d.maintenance)),
    },
    header: {
        comm_engage: tooltip("Community Engagement", "Community Engagement metrics"),
        dev_resp: tooltip("Developer Responsivness", "Developer Responsiveness metrics"),
        maintenance: tooltip(
            "Maintenance Deficit",
            "Community Engagment minus Developer Responsivess (rescaled)"
        ),
    },
})
```

---

## Additional metrics and indicators

The following show several more distinct indicators of maintenance need, all of
which are assessed over the most recent period of repository activity:

- _Ctb. Absence_: A measure of "contributor absence" for each repository,
    indicating maintenance deficit arising through absence of primary
    contributors.
- _Resp. Time_: The average time for a core maintainer to respond to a new
    issue or pull request
- _Issue Labels_: The proportion of issues with labels
- _Prop. Bugs_: The proportion of new issues opened that were bug reports

```{r load-table-data}
data_extra_metrics <- readRDS (fs::path ("data", "results-data-ctb-absence.Rds")) |>
    dplyr::filter (what == "absence") |>
    dplyr::group_by (repo) |>
    dplyr::summarise (ctb_absence = max (measure)) |>
    dplyr::full_join (readRDS (fs::path ("data", "results-data-issue-resp.Rds")), by = "repo") |>
    dplyr::full_join (readRDS (fs::path ("data", "results-data-issue-bugs.Rds")), by = "repo")
# data_ctb_abs_ctb <- dplyr::group_by (data_ctb_abs, name) |>
#     dplyr::summarise (measure = mean (measure), n = dplyr::n ())
```

```{r ojs-in-extra-metrics}
ojs_define (data_extra_metrics_in = data_extra_metrics)
```

```{ojs}
extraMetricsTable = {
    return transpose(data_extra_metrics_in).map(row => ({
        ...row,
    }));
}
```

```{ojs}
Inputs.table(extraMetricsTable, {
    width: {
        repo: 100,
        ctb_absence: 200,
        response: 200,
        labels: 200,
        bugs: 200,
    },
    format: {
        repo: d => pkgfmt(d),
        ctb_absence: sparkbar(d3.max(extraMetricsTable, d => d.ctb_absence)),
        response: sparkbar(d3.max(extraMetricsTable, d => d.response)),
        labels: sparkbar(d3.max(extraMetricsTable, d => d.labels)),
        bugs: sparkbar(d3.max(extraMetricsTable, d => d.bugs)),
    },
    header: {
        ctb_absence: tooltip("Ctb. Absence", "Contributor absence factor"),
        response: tooltip("Resp. Time", "Time to respond to GitHub issues and pull requests"),
        labels: tooltip("Issue Labels", "Proportion of labelled issues"),
        bugs: tooltip("Prop. Bugs", "Proportion of issues and PRs which are about bugs."),
    },
})
```

---

### Contributor Absence

Finally, this table shows a metric of main contributor absence. Values are only
shown for main contributors who have been recently absent from repositories. A
contributor who has been entirely absent during the most recent period, and was
responsible for 100% of the commits from some number, _n_, repositories, would
have a contributor absence score of _n_. The same contributor absence of _n_
could also reflect somebody contributing exactly 50% of the code to
2$\times$_n_ repositories, and being entirely absent during the recent period.
Any contributions by that contributor during the recent period would reduce the
absence factor. In general, high absence factors describe recently absent
contributors who have previously been major contributors to numerous
repositories.

```{r load-data}
data_ctb_abs_ctb <- readRDS (fs::path ("data", "results-data-ctb-absence.Rds")) |>
    dplyr::filter (what == "absence") |>
    dplyr::group_by (name, login) |>
    dplyr::summarise (measure = sum (measure), .groups = "keep")
# Names and/or logins may be repeated:
dups <- which (duplicated (data_ctb_abs_ctb$login))
if (length (dups) > 0L) {
    dups <- data_ctb_abs_ctb$login [dups]
    names <- vapply (dups, function (d) {
        index <- which (data_ctb_abs_ctb$login == d)
        nms <- data_ctb_abs_ctb$name [index]
        # Pick first name that is the longest and has most white space:
        rank1 <- order (nchar (nms), decreasing = TRUE)
        n_spaces <- vapply (
            gregexpr ("\\s", nms),
            function (s) length (which (s > 0)),
            integer (1L)
        )
        rank2 <- order (n_spaces, decreasing = TRUE)
        rank <- order (rank1 + rank2)
        nms [rank [1L]]
    }, character (1L))
    for (d in seq_along (dups)) {
        index <- which (data_ctb_abs_ctb$login == dups [d])
        data_ctb_abs_ctb$name [index] <- names [d]
    }
    data_ctb_abs_ctb <- data_ctb_abs_ctb |>
        dplyr::group_by (name, login) |>
        dplyr::summarise (measure = sum (measure), .groups = "keep")
}

# Then only include contributors with an absence factor of 1, equivalent to
# complete absence from a single repo:
data_ctb_abs_ctb <- data_ctb_abs_ctb |>
    dplyr::filter (measure >= 1) |>
    dplyr::arrange (dplyr::desc (measure))
```

```{r ojs-in-models}
ojs_define (ctb_abs_ctb_in = data_ctb_abs_ctb)
```

```{ojs plot-latest}
Plot = import("https://esm.sh/@observablehq/plot")
```

```{ojs}
ctb_abs_ctb = {
    return transpose(ctb_abs_ctb_in).map(row => ({
        ...row,
    }));
}
ctb_abs_ctb_len = ctb_abs_ctb.length;
```


```{ojs}
// The 'ctbfmt' function set the localStorage 'orgmetricsMaintainer' value, but
// the inputs here are full names, no GitHub handles, so unless the are
// identical, this currently fails and needs to be fixed.
Inputs.table(ctb_abs_ctb, {
    width: {
        name: 200,
        login: 200,
        measure: 200,
    },
    format: {
        login: d => ctbfmt(d),
        measure: sparkbar(d3.max(ctb_abs_ctb, d => d.measure)),
    },
    header: {
        measure: tooltip("Ctb. Absence", "Contributor absence factor"),
    },
})
```

## Maintenance Priorities

This section links to repositories with distinct maintenance priorities.

```{r}
# Code to get outlier metrics for packages identified as having maintenance
# priorities:
threshold <- 0.8
threshold <- 0.5 + threshold / 2
num_sds <- qnorm (threshold, 0, 1)
data_metrics <- readRDS (fs::path ("data", "results-metrics.Rds"))
# which.max does not work for dates, but max does
index1 <- which (names (data_metrics) == max (names (data_metrics)))
limits <- data_metrics [[index1]] |>
    dplyr::group_by (name) |>
    dplyr::filter (!is.na (value)) |>
    dplyr::summarise (
        lower = mean (value) - num_sds * sd (value),
        upper = mean (value) + num_sds * sd (value)
    )
m <- data_metrics [[index1]] |>
    dplyr::left_join (limits, by = "name") |>
    dplyr::group_by (name) |>
    dplyr::filter (!is.na (value)) |>
    dplyr::mutate (below = value < lower) |>
    dplyr::select (-lower, -upper) |>
    dplyr::filter (below) |>
    dplyr::arrange (name) |>
    dplyr::left_join (repo_urls, by = "package", relationship = "many-to-many")

# Then reduce to only the identified outlier packages:
m <- dplyr::filter (m, package %in% data$package) |>
    dplyr::group_by (package)

# Update metrics names to descriptions:
rm_metrics_json <- system.file (
    "extdata",
    "metrics-models",
    "metrics-models.json",
    package = "repometrics"
) |>
    jsonlite::read_json (simplify = TRUE)
rm_metrics_dat <- rm_metrics_json$metrics
m$name <- rm_metrics_dat$airtable_name [match (m$name, rm_metrics_dat$name)]

metrics <- unique (m$name)
metrics_data <- lapply (metrics, function (i) {
    list (
        h = i,
        text = m$package [which (m$name == i)],
        url = m$url [which (m$name == i)]
    )
})
```



```{r}
# NOTE that the href values here are filled with the sub-domain when deployed,
# so DO NOT need to be modified!
bslib::page_fillable (
    lapply (metrics_data, function (i) {
        htmltools::div (
            htmltools::h3 (i$h),
            if (length (i$text) == 1L) {
                tags$p (
                    bsicons::bs_icon ("caret-right"),
                    tags$a (
                        href = "/repometrics-demo/repo.html",
                        onclick = sprintf ("localStorage.setItem('orgmetricsRepo', '%s')", i$text),
                        i$text
                    )
                )
            } else {
                htmltools::tagList (lapply (seq_along (i$text), function (j) {
                    tags$p (
                        bsicons::bs_icon ("caret-right"),
                        tags$a (
                            href = "/repometrics-demo/repo.html",
                            onclick = sprintf ("localStorage.setItem('orgmetricsRepo', '%s')", i$text [j]),
                            i$text [j]
                        )
                    )
                }))
            },
            style = "padding-bottom: 1rem; padding-top: 0px; border-bottom: 1px solid #eee;"
        )
    })
)
```


-----
