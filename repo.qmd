---
title: "Repositories"
execute:
  echo: false
format: 
  html:
    fig-width: 8
    fig-height: 4
    code-fold: false
---

<!---
******** START UTILITY FUNCTIONS ********
--->


```{ojs}
function sparkbar(max) {
  const colourScale = d3.scaleSequential(d3.interpolateCool)
    .domain([0, max]);

  return (x) => htl.html`<div style="
    background: ${colourScale(x)};
    color: black;
    width: ${100 * x / max}%;
    float: right;
    padding-right: 3px;
    box-sizing: border-box;
    overflow: visible;
    display: flex;
    justify-content: end;">${x.toFixed(2).toLocaleString("en-US")}`
}
```

<!---
******** END UTILITY FUNCTIONS ********
--->

This page identifies maintenance priorities for a selected repository, in
terms of both [CHAOSS
models](https://chaoss.community/kbtopic/all-metrics-models/), and the
individual [CHAOSS metrics](https://chaoss.community/kbtopic/all-metrics/)
which comprise those models. In its present state, this is mostly a
proof-of-concept, and is not as well developed as the accompanying
[*Organizational Maintenance* page](./org.html).

The "Outliers only" selector immediate below determines whether values shown
for both models and metrics are outliers only (default of "true"), or whether
all values are shown ("false").


```{r load-pkg, echo = FALSE, message = FALSE}
library (orgmetrics)
```

```{r load-data}
data_metrics <- readRDS ("results-metrics.Rds")
# which.max does not work for dates, but max does
index1 <- which (names (data_metrics) == max (names (data_metrics)))
data_metrics <- data_metrics [[index1]]
data_metrics$value [which (is.na (data_metrics$value))] <- 0
data_models <- readRDS ("results-models.Rds")
data_repo_src <- readRDS ("results-data-repo-src.Rds")

data_ctb_abs <- readRDS ("results-data-ctb-absence.Rds")
data_issue_resp <- readRDS ("results-data-issue-resp.Rds")
data_issue_bugs <- readRDS ("results-data-issue-bugs.Rds")
```

```{r data outliers}
threshold <- 0.9
data_metrics <- data_metrics |>
    dplyr::group_by (name) |>
    dplyr::arrange (value) |>
    dplyr::mutate (
        outlier = dplyr::row_number (value) <= dplyr::n () * (1 - threshold) |
            dplyr::row_number (value) >= dplyr::n () * threshold
    ) |>
    dplyr::arrange (package, dplyr::desc (value))

data_models <- data_models |>
    dplyr::group_by (name) |>
    dplyr::arrange (value) |>
    dplyr::mutate (
        outlier = dplyr::row_number (value) <= dplyr::n () * (1 - threshold) |
            dplyr::row_number (value) >= dplyr::n () * threshold
    ) |>
    dplyr::arrange (package, dplyr::desc (value))

data_pkgcheck <- readRDS ("results-pkgcheck.Rds")
names (data_pkgcheck) <- gsub ("^.*\\/", "", names (data_pkgcheck))
pkgcheck_summaries <- lapply (data_pkgcheck, function (d) {
    out <- pkgcheck:::summarise_all_checks (d)
    out <- gsub ("\\:heavy\\_check\\_mark\\:", "&#9989;", out)
    out <- gsub ("\\:heavy\\_multiplication\\_x\\:", "&#10060;", out)
    out <- gsub ("\\:eyes\\:", "&#128064;", out)
    gsub ("^\\-(\\s?)", "", grep ("^\\-", out, value = TRUE))
})
measures_rm <- c (
    "loc_vignettes", "data_size_median", "n_fns_r_not_exported",
    "rel_whitespace_R", "rel_whitespace_vignettes", "rel_whitespace_tests"
)
pkgcheck_stats <- lapply (data_pkgcheck, function (d) {
    d$info$pkgstats |>
        dplyr::select (-noteworthy) |>
        dplyr::filter (!measure %in% measures_rm) |>
        dplyr::mutate (value = dplyr::case_when (
            measure == "data_size_total" ~ round (value / 1024),
            .default = value
        )) |>
        dplyr::mutate (measure = dplyr::case_when (
            measure == "files_R" ~ "Nr. Files: R",
            measure == "files_vignettes" ~ "Nr. Vignettes",
            measure == "files_tests" ~ "Nr. Files: tests",
            measure == "loc_R" ~ "LOC: R",
            measure == "loc_tests" ~ "LOC: tests",
            measure == "num_vignettes" ~ "Nr. vignettes",
            measure == "data_size_total" ~ "Data size (kB)",
            measure == "n_fns_r" ~ "Nr. fns: R",
            measure == "n_fns_r_exported" ~ "Nr. exported fns: R",
            measure == "n_fns_per_file_r" ~ "Nr. fns per file",
            measure == "num_params_per_fn" ~ "Nr. params per fn",
            measure == "loc_per_fn_r" ~ "LOC per fn: R",
            measure == "loc_per_fn_r_exp" ~ "LOC per exported fn: R",
            measure == "loc_per_fn_r_non_exp" ~ "LOC per non-exported fn: R",
            measure == "doclines_per_fn_exp" ~ "Doc. lines per exported fn.",
            measure == "doclines_per_fn_not_exp" ~ "Doc. lines per non-exported fn.",
            measure == "fn_call_network_size" ~ "Nr. nodes in fn. call network",
            .default = measure
        ))
})
```

```{r ojs-in-metrics}
ojs_define (metrics_in = data_metrics)
ojs_define (models_in = data_models)
ojs_define (repo_src_in = data_repo_src)
ojs_define (ctb_abs_in = data_ctb_abs)
ojs_define (issue_resp_in = data_issue_resp)
ojs_define (issue_bugs_in = data_issue_bugs)
ojs_define (pkgcheck_in = pkgcheck_summaries)
ojs_define (pkgcheck_stats_in = pkgcheck_stats)
```

```{ojs plot-latest}
Plot = import("https://esm.sh/@observablehq/plot")
```

```{ojs}
metricsTranspose = {
    return transpose(metrics_in).map(row => ({
        ...row,
    }));
}
repo_src = {
    return transpose(repo_src_in).map(row => ({
        ...row,
    }));
}
ctb_absTranspose = {
    return transpose(ctb_abs_in).map(row => ({
        ...row,
    }));
}
issue_respTranspose = {
    return transpose(issue_resp_in).map(row => ({
        ...row,
    }));
}
issue_bugsTranspose = {
    return transpose(issue_bugs_in).map(row => ({
        ...row,
    }));
}
```

```{ojs get-all-repos}
// Get array of unique repo names for input selector:
reposAll = metricsTranspose.map(function(item) {
    return item.package;
});
repos = Array.from(new Set(reposAll));
repoSet = localStorage.getItem("orgmetricsRepo") || repos [0]
viewof repo = Inputs.select(
    repos,
    {
        multiple: false,
        value: repoSet,
        label: htl.html`<b>Repository:</b>`
    }
)
s = localStorage.setItem("orgmetricsRepo", repo.toString());
```

<div style="margin-top: 20px; margin-bottom: 20px;"></div>

```{ojs}
// and get URL for selected repo
repoURL = repo_src.filter(function(r) {
    return r.package === repo
})[0].url;
htl.html`<div>Click here to see the <a href=${repoURL} target="_blank">${repo} repository</a>.</div>`
```

<div style="margin-top: 20px; margin-bottom: 20px;"></div>

```{ojs}
ctb_abs = ctb_absTranspose.filter(function(r) {
    return r.repo === repo
})
issue_resp = issue_respTranspose.filter(function(r) {
    return r.repo === repo
})
issue_bugs = issue_bugsTranspose.filter(function(r) {
    return r.repo === repo
})
```


## pkgcheck Summary

This shows the summary output from [rOpenSci's `pkgcheck`
package](https://docs.ropensci.org/pkgcheck). Passing checks are marked by
&#9989;; failing checks by &#10060;; and optional checks that may be worth
examining with &#128064;.

```{ojs}
this_pkg_summary = pkgcheck_in[repo];

function unescapeHtml(unsafe) {
  const textarea = document.createElement('textarea');
  textarea.innerHTML = unsafe;
  return textarea.value;
}

htl.html`
  <div>${this_pkg_summary.map((item) => htl.html.fragment`<ul>
    <li>${unescapeHtml(item)}</li>
  </ul>`)}</div>`
```


### Statistical properties

The "Limits" slider below can be used to reduce statistical properties to only
those lying in the lower or upper percentiles of the specified value. Note in
the measures that "LOC" = "Lines-of-Code".

```{ojs}
viewof statsLimit = Inputs.range(
    [0,50],
    {value: 10, step: 5, label: htl.html`<b>Limits:</b>`}
);
```

<div style="margin-top: 20px; margin-bottom: 20px;"></div>

```{ojs}
pkgStatsData = {
    return transpose(pkgcheck_stats_in[repo]).map(row => ({
        ...row,
    })).filter(function(m) {
        return m.percentile <= statsLimit || m.percentile >= (100 - statsLimit)
    });
}
```

```{ojs}
Inputs.table(pkgStatsData, {
    format: {
        percentile: sparkbar(100),
        noteworth: null,
    },
    header: {
        measure: "Measure",
        value: "Value",
        percentile: "Percentile"
    }
})
```


## CHAOSS models

This first graph shows scores for the various [CHAOSS (*Community Health
Analytics in Open Source Software*)
models](https://chaoss.community/kbtopic/all-metrics-models/) for a selected
repository. Each of these models is an aggregation of several underlying
[metrics](https://chaoss.community/kbtopic/all-metrics/), which can be examined
in the following sub-section.

```{ojs}
viewof outliersOnly = Inputs.radio(
    ["true", "false"],
    {
        value: "true",
        label: htl.html`<b>Outliers only:</b>`,
    }
)
```

```{ojs}
models_all = {
    return transpose(models_in).map(row => ({
        ...row,
    }));
}
models_final = models_all.filter(function(mod) {
    return mod.name === "final"
})
model_repoAll = models_all.filter(function(mod) {
    return mod.package === repo && mod.name !== "final"
})
model_repo = outliersOnly === "true" ?
    model_repoAll.filter(function(m) {
        return m.outlier === true;
    }) : model_repoAll;
model_repo_len = model_repo.length
model_repo_ht_mult = model_repo_len < 10 ? 80 : 40
```

```{ojs colour-scales}
// Bar colours should be scaled to full data range, not just restricted range
// of filtered data.
fullScaleValues = model_repoAll.map(d => d.value);
minVal = Math.min(...fullScaleValues);
maxVal = Math.max(...fullScaleValues);
```


```{ojs plot-filtered-repo-models}
Plot.plot({
    height: model_repo_ht_mult * model_repo_len,
    marginLeft: 60,
    marginRight: 160,
    marginTop: 50,
    marginBottom: 50,
    axis: null,
    x: {
        axis: "top",
        grid: true,
        label: "Model Scores"
    },
    y: { grid: true },
    marks: [
        Plot.barX(model_repo, {
            y: "name",
            x: "value",
            sort: {y: "-x" },
            fill: "value",
        }),
        Plot.barX(model_repo,
            Plot.pointer(
            {
                y: "name",
                x: "value",
                sort: {y: "-x" },
                stroke: "gray",
                fill: "value",
                strokeWidth: 2,
            })
        ),
        Plot.text(model_repo, {
            x: (d) => d.value < 0 ? 0 : d.value,
            y: "name",
            text: "name",
            textAnchor: "start",
            fontSize: 16,
            dx: 5
        })
    ],
    color: {
        scheme: "Cool",
        type: "linear",
        domain: [minVal, maxVal]
    }
})
```

## CHAOSS metrics

This graph provides more detailed insight into the state of the selected
repository, through showing values for individual [CHAOSS
metrics](https://chaoss.community/kbtopic/all-metrics/) used to inform the
aggregate models.

```{ojs}
metrics = outliersOnly === "true" ?
    metricsTranspose.filter(function(m) {
        return m.outlier === true;
    }) : metricsTranspose;

metrics_repo = metrics.filter(function(mod) {
    return mod.package === repo
})
metrics_repo_len = metrics_repo.length
```


```{ojs plot-filtered-repo-metrics}
Plot.plot({
    height: 40 * metrics_repo_len,
    marginLeft: 60,
    marginRight: 160,
    marginTop: 50,
    marginBottom: 50,
    axis: null,
    x: {
        axis: "top",
        grid: true,
        label: "Metric Scores"
    },
    y: { grid: true },
    marks: [
        Plot.barX(metrics_repo, {
            y: "name",
            x: "value",
            sort: {y: "-x" },
            fill: "value",
        }),
        Plot.barX(metrics_repo,
            Plot.pointer(
            {
                y: "name",
                x: "value",
                sort: {y: "-x" },
                stroke: "gray",
                fill: "value",
                strokeWidth: 2,
            })
        ),
        Plot.text(metrics_repo, {
            x: (d) => d.value < 0 ? 0 : d.value,
            y: "name",
            text: "name",
            textAnchor: "start",
            fontSize: 16,
            dx: 5
        })
    ],
    color: {
        scheme: "Cool",
        type: "ordinal"
    }
})
```
